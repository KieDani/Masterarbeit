<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>my_models API documentation</title>
<meta name="description" content="Definition of some hamiltonians and the correspondending graphs and hilbert spaces â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>my_models</code></h1>
</header>
<section id="section-intro">
<p>Definition of some hamiltonians and the correspondending graphs and hilbert spaces</p>
<p>Here, some hamiltonians can be loaded together with the graph and hilbert space.
So far, the Heisnbergchain and the AKLT model are implemented.
Use the method get_hamiltonian to create hamiltonian, graph and hilbert space.</p>
<p>This project requires the following libraries:
netket, numpy, scipy, jax, jaxlib, networkx, torch, tqdm, matplotlib
This file contains the following functions:</p>
<pre><code>* build_Heisenbergchain_S1
* build_Heisenbergchain_S1_transformed
* build_AKLTchain
* build_AKLTchain_transformed
* get_hamiltonian
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Definition of some hamiltonians and the correspondending graphs and hilbert spaces

Here, some hamiltonians can be loaded together with the graph and hilbert space.
So far, the Heisnbergchain and the AKLT model are implemented.
Use the method get_hamiltonian to create hamiltonian, graph and hilbert space.

This project requires the following libraries:
netket, numpy, scipy, jax, jaxlib, networkx, torch, tqdm, matplotlib
This file contains the following functions:

    * build_Heisenbergchain_S1
    * build_Heisenbergchain_S1_transformed
    * build_AKLTchain
    * build_AKLTchain_transformed
    * get_hamiltonian
&#34;&#34;&#34;
import netket as nk
import numpy as np
import scipy
import networkx as nx
import sys


def build_Heisenbergchain_S1(L, periodic = False):
    &#34;&#34;&#34;Loading the Heisenberg chain
        The original Heisenberg chain is created

             Args:
                L (int) : The number of sites of the lattice
                periodic (bool) : True, if we have a periodic lattice. False, if we have an open lattice.
                &#34;&#34;&#34;
    print(&#39;Building the normal S=1 Heisenberg chain&#39;)
    J = [1]
    gnx = nx.Graph()
    if(periodic == False):
        tmp = -1
    else:
        tmp = 0
    for i in range(L + tmp):
        gnx.add_edge(i, (i + 1) % L)
    g = nk.graph.Graph(nodes=list(gnx.nodes), edges=list(gnx.edges))

    # Printing out the graph information
    #print(&#39;This graph has &#39; + str(g.n_nodes) + &#39; sites&#39;)
    #print(&#39;with the following set of edges: &#39; + str(g.n_edges))

    hi = nk.hilbert.Spin(s=1, N=g.n_nodes)

    # Pauli Matrices for Spin 1
    sigmax = 1. / np.sqrt(2) * np.asarray([[0, 1, 0], [1, 0, 1], [0, 1, 0]])
    sigmaz = np.asarray([[1, 0, 0], [0, 0, 0], [0, 0, -1]])
    sigmay = 1. / np.sqrt(2) * np.asarray([[0, -1j, 0], [1j, 0, -1j], [0, 1j, 0]])

    # Bond Operator
    interaction = np.kron(sigmaz, sigmaz) + np.kron(sigmax, sigmax) + np.kron(sigmay, sigmay)

    bond_operator = [
        (J[0] * interaction).tolist(),
    ]

    # Custom Graph Hamiltonian operator
    ha = nk.operator.GraphOperator(hi, g, bond_ops=bond_operator)

    return ha, hi, g


#TODO check, if the results are correct
def build_AKLTchain(L, periodic = False):
    &#34;&#34;&#34;Loading the AKLT chain
        The original AKLT chain is loaded

            Args:
                L (int) : The number of sites of the lattice
                periodic (bool) : True, if we have a periodic lattice. False, if we have an open lattice.
                &#34;&#34;&#34;
    print(&#39;Building the normal AKLT chain&#39;)
    J = [1]
    gnx = nx.Graph()
    if (periodic == False):
        tmp = -1
    else:
        tmp = 0
    for i in range(L + tmp):
        gnx.add_edge(i, (i + 1) % L)
    g = nk.graph.Graph(nodes=list(gnx.nodes), edges=list(gnx.edges))

    # Printing out the graph information
    #print(&#39;This graph has &#39; + str(g.n_nodes) + &#39; sites&#39;)
    #print(&#39;with the following set of edges: &#39; + str(g.n_edges))

    hi = nk.hilbert.Spin(s=1, N=g.n_nodes)

    # Pauli Matrices for Spin 1
    sigmax = 1. / np.sqrt(2) * np.asarray([[0, 1, 0], [1, 0, 1], [0, 1, 0]])
    sigmaz = np.asarray([[1, 0, 0], [0, 0, 0], [0, 0, -1]])
    sigmay = 1. / np.sqrt(2) * np.asarray([[0, -1j, 0], [1j, 0, -1j], [0, 1j, 0]])

    linearterm = np.kron(sigmaz, sigmaz) + np.kron(sigmax, sigmax) + np.kron(sigmay, sigmay)

    # Bond Operator
    interaction = linearterm + 1./3 * np.dot(linearterm, linearterm)

    bond_operator = [
        (J[0] * interaction).tolist(),
    ]

    # Custom Graph Hamiltonian operator
    ha = nk.operator.GraphOperator(hi, g, bond_ops=bond_operator)

    return ha, hi, g


def build_Heisenbergchain_S1_transformed(L, periodic = False):
    &#34;&#34;&#34;Loading the transformed Heisenberg chain. See https://doi.org/10.1007/BF02097239
        The transformed model is easier to solve with NetKet.

            Args:
                L (int) : The number of sites of the lattice
                periodic (bool) : True, if we have a periodic lattice. False, if we have an open lattice.
                &#34;&#34;&#34;
    print(&#39;Building the transformed S=1 Heisenberg chain&#39;)
    J = [1]
    gnx = nx.Graph()
    if (periodic == False):
        tmp = -1
    else:
        tmp = 0
    for i in range(L + tmp):
        gnx.add_edge(i, (i + 1) % L)
        print(str(i) + &#39; &#39; + str(i + 1))
    g = nk.graph.Graph(nodes=list(gnx.nodes), edges=list(gnx.edges))

    # Printing out the graph information
    #print(&#39;This graph has &#39; + str(g.n_nodes) + &#39; sites&#39;)
    #print(&#39;with the following set of edges: &#39; + str(g.n_edges))

    hi = nk.hilbert.Spin(s=1, N=g.n_nodes)

    interaction = np.asarray([[-1, 0, 0, 0, -1, 0, 0, 0, 0], [0, 0, 0, -1, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0],
                              [0, -1, 0, 0, 0, 0, 0, 0, 0], [-1, 0, 0, 0, 0, 0, 0, 0, -1], [0, 0, 0, 0, 0, 0, 0, -1, 0],
                              [0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, -1, 0, 0, 0], [0, 0, 0, 0, -1, 0, 0, 0, -1]])

    bond_operator = [
        (J[0] * interaction).tolist(),
    ]

    # Custom Graph Hamiltonian operator
    ha = nk.operator.GraphOperator(hi, g, bond_ops=bond_operator)

    return ha, hi, g


#TODO check, if the results are correct
def build_AKLTchain_transformed(L, periodic = False):
    &#34;&#34;&#34;Loading the transformed Heisenberg chain. See https://doi.org/10.1007/BF02097239
        The transformed model is easier to solve with NetKet.

            Args:
                L (int) : The number of sites of the lattice
                periodic (bool) : True, if we have a periodic lattice. False, if we have an open lattice.
                &#34;&#34;&#34;
    print(&#39;Building the transformed AKLT chain&#39;)
    J = [1]
    gnx = nx.Graph()
    if (periodic == False):
        tmp = -1
    else:
        tmp = 0
    for i in range(L + tmp):
        gnx.add_edge(i, (i + 1) % L)
    g = nk.graph.Graph(nodes=list(gnx.nodes), edges=list(gnx.edges))

    # Printing out the graph information
    #print(&#39;This graph has &#39; + str(g.n_nodes) + &#39; sites&#39;)
    #print(&#39;with the following set of edges: &#39; + str(g.n_edges))

    hi = nk.hilbert.Spin(s=1, N=g.n_nodes)

    # Pauli Matrices for Spin_size_1_t 1
    sigmax = 1. / np.sqrt(2) * np.asarray([[0, 1, 0], [1, 0, 1], [0, 1, 0]])
    sigmaz = np.asarray([[1, 0, 0], [0, 0, 0], [0, 0, -1]])
    sigmay = 1. / np.sqrt(2) * np.asarray([[0, -1j, 0], [1j, 0, -1j], [0, 1j, 0]])
    expX = np.asarray([[0, 0, -1], [0, -1, 0], [-1, 0, 0]])
    expZ = np.asarray([[-1, 0, 0], [0, 1, 0], [0, 0, -1]])

    h = -np.kron(sigmaz, sigmaz) - np.kron(sigmax, sigmax) + np.kron(np.dot(sigmay, expZ), np.dot(expX, sigmay))

    # Bond Operator
    interaction = h + 1./3 * np.dot(h, h)

    bond_operator = [
        (J[0] * interaction).tolist(),
    ]

    # Custom Graph Hamiltonian operator
    ha = nk.operator.GraphOperator(hi, g, bond_ops=bond_operator)

    return ha, hi, g


def get_hamiltonian(hamiltonian_name, L, periodic = False):
    &#34;&#34;&#34;Method to choose the desired model.
        Mutiple models can be easily chosen.

            Args:
                L (int) : The number of sites of the lattice
                periodic (bool) : True, if we have a periodic lattice. False, if we have an open lattice.
                hamiltonian_name (str) : Possible Inputs are &#39;transformed_Heisenberg&#39;, &#39;original_heisenberg&#39;,
                        &#39;transformed_AKLT&#39;, &#39;original_AKLT&#39;
                &#34;&#34;&#34;
    if(hamiltonian_name == &#39;transformed_Heisenberg&#39;):
        return build_Heisenbergchain_S1_transformed(L, periodic)
    elif(hamiltonian_name == &#39;original_Heisenberg&#39;):
        return build_Heisenbergchain_S1(L, periodic)
    elif(hamiltonian_name == &#39;transformed_AKLT&#39;):
        return build_AKLTchain_transformed(L, periodic)
    elif(hamiltonian_name == &#39;original_AKLT&#39;):
        return build_AKLTchain(L, periodic)
    else:
        print(&#39;The desired hamiltonian was spelled wrong!&#39;)
        sys.stdout.flush()
        return None</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="my_models.build_AKLTchain"><code class="name flex">
<span>def <span class="ident">build_AKLTchain</span></span>(<span>L, periodic=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Loading the AKLT chain
The original AKLT chain is loaded</p>
<pre><code>Args:
    L (int) : The number of sites of the lattice
    periodic (bool) : True, if we have a periodic lattice. False, if we have an open lattice.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_AKLTchain(L, periodic = False):
    &#34;&#34;&#34;Loading the AKLT chain
        The original AKLT chain is loaded

            Args:
                L (int) : The number of sites of the lattice
                periodic (bool) : True, if we have a periodic lattice. False, if we have an open lattice.
                &#34;&#34;&#34;
    print(&#39;Building the normal AKLT chain&#39;)
    J = [1]
    gnx = nx.Graph()
    if (periodic == False):
        tmp = -1
    else:
        tmp = 0
    for i in range(L + tmp):
        gnx.add_edge(i, (i + 1) % L)
    g = nk.graph.Graph(nodes=list(gnx.nodes), edges=list(gnx.edges))

    # Printing out the graph information
    #print(&#39;This graph has &#39; + str(g.n_nodes) + &#39; sites&#39;)
    #print(&#39;with the following set of edges: &#39; + str(g.n_edges))

    hi = nk.hilbert.Spin(s=1, N=g.n_nodes)

    # Pauli Matrices for Spin 1
    sigmax = 1. / np.sqrt(2) * np.asarray([[0, 1, 0], [1, 0, 1], [0, 1, 0]])
    sigmaz = np.asarray([[1, 0, 0], [0, 0, 0], [0, 0, -1]])
    sigmay = 1. / np.sqrt(2) * np.asarray([[0, -1j, 0], [1j, 0, -1j], [0, 1j, 0]])

    linearterm = np.kron(sigmaz, sigmaz) + np.kron(sigmax, sigmax) + np.kron(sigmay, sigmay)

    # Bond Operator
    interaction = linearterm + 1./3 * np.dot(linearterm, linearterm)

    bond_operator = [
        (J[0] * interaction).tolist(),
    ]

    # Custom Graph Hamiltonian operator
    ha = nk.operator.GraphOperator(hi, g, bond_ops=bond_operator)

    return ha, hi, g</code></pre>
</details>
</dd>
<dt id="my_models.build_AKLTchain_transformed"><code class="name flex">
<span>def <span class="ident">build_AKLTchain_transformed</span></span>(<span>L, periodic=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Loading the transformed Heisenberg chain. See <a href="https://doi.org/10.1007/BF02097239">https://doi.org/10.1007/BF02097239</a>
The transformed model is easier to solve with NetKet.</p>
<pre><code>Args:
    L (int) : The number of sites of the lattice
    periodic (bool) : True, if we have a periodic lattice. False, if we have an open lattice.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_AKLTchain_transformed(L, periodic = False):
    &#34;&#34;&#34;Loading the transformed Heisenberg chain. See https://doi.org/10.1007/BF02097239
        The transformed model is easier to solve with NetKet.

            Args:
                L (int) : The number of sites of the lattice
                periodic (bool) : True, if we have a periodic lattice. False, if we have an open lattice.
                &#34;&#34;&#34;
    print(&#39;Building the transformed AKLT chain&#39;)
    J = [1]
    gnx = nx.Graph()
    if (periodic == False):
        tmp = -1
    else:
        tmp = 0
    for i in range(L + tmp):
        gnx.add_edge(i, (i + 1) % L)
    g = nk.graph.Graph(nodes=list(gnx.nodes), edges=list(gnx.edges))

    # Printing out the graph information
    #print(&#39;This graph has &#39; + str(g.n_nodes) + &#39; sites&#39;)
    #print(&#39;with the following set of edges: &#39; + str(g.n_edges))

    hi = nk.hilbert.Spin(s=1, N=g.n_nodes)

    # Pauli Matrices for Spin_size_1_t 1
    sigmax = 1. / np.sqrt(2) * np.asarray([[0, 1, 0], [1, 0, 1], [0, 1, 0]])
    sigmaz = np.asarray([[1, 0, 0], [0, 0, 0], [0, 0, -1]])
    sigmay = 1. / np.sqrt(2) * np.asarray([[0, -1j, 0], [1j, 0, -1j], [0, 1j, 0]])
    expX = np.asarray([[0, 0, -1], [0, -1, 0], [-1, 0, 0]])
    expZ = np.asarray([[-1, 0, 0], [0, 1, 0], [0, 0, -1]])

    h = -np.kron(sigmaz, sigmaz) - np.kron(sigmax, sigmax) + np.kron(np.dot(sigmay, expZ), np.dot(expX, sigmay))

    # Bond Operator
    interaction = h + 1./3 * np.dot(h, h)

    bond_operator = [
        (J[0] * interaction).tolist(),
    ]

    # Custom Graph Hamiltonian operator
    ha = nk.operator.GraphOperator(hi, g, bond_ops=bond_operator)

    return ha, hi, g</code></pre>
</details>
</dd>
<dt id="my_models.build_Heisenbergchain_S1"><code class="name flex">
<span>def <span class="ident">build_Heisenbergchain_S1</span></span>(<span>L, periodic=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Loading the Heisenberg chain
The original Heisenberg chain is created</p>
<pre><code> Args:
    L (int) : The number of sites of the lattice
    periodic (bool) : True, if we have a periodic lattice. False, if we have an open lattice.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_Heisenbergchain_S1(L, periodic = False):
    &#34;&#34;&#34;Loading the Heisenberg chain
        The original Heisenberg chain is created

             Args:
                L (int) : The number of sites of the lattice
                periodic (bool) : True, if we have a periodic lattice. False, if we have an open lattice.
                &#34;&#34;&#34;
    print(&#39;Building the normal S=1 Heisenberg chain&#39;)
    J = [1]
    gnx = nx.Graph()
    if(periodic == False):
        tmp = -1
    else:
        tmp = 0
    for i in range(L + tmp):
        gnx.add_edge(i, (i + 1) % L)
    g = nk.graph.Graph(nodes=list(gnx.nodes), edges=list(gnx.edges))

    # Printing out the graph information
    #print(&#39;This graph has &#39; + str(g.n_nodes) + &#39; sites&#39;)
    #print(&#39;with the following set of edges: &#39; + str(g.n_edges))

    hi = nk.hilbert.Spin(s=1, N=g.n_nodes)

    # Pauli Matrices for Spin 1
    sigmax = 1. / np.sqrt(2) * np.asarray([[0, 1, 0], [1, 0, 1], [0, 1, 0]])
    sigmaz = np.asarray([[1, 0, 0], [0, 0, 0], [0, 0, -1]])
    sigmay = 1. / np.sqrt(2) * np.asarray([[0, -1j, 0], [1j, 0, -1j], [0, 1j, 0]])

    # Bond Operator
    interaction = np.kron(sigmaz, sigmaz) + np.kron(sigmax, sigmax) + np.kron(sigmay, sigmay)

    bond_operator = [
        (J[0] * interaction).tolist(),
    ]

    # Custom Graph Hamiltonian operator
    ha = nk.operator.GraphOperator(hi, g, bond_ops=bond_operator)

    return ha, hi, g</code></pre>
</details>
</dd>
<dt id="my_models.build_Heisenbergchain_S1_transformed"><code class="name flex">
<span>def <span class="ident">build_Heisenbergchain_S1_transformed</span></span>(<span>L, periodic=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Loading the transformed Heisenberg chain. See <a href="https://doi.org/10.1007/BF02097239">https://doi.org/10.1007/BF02097239</a>
The transformed model is easier to solve with NetKet.</p>
<pre><code>Args:
    L (int) : The number of sites of the lattice
    periodic (bool) : True, if we have a periodic lattice. False, if we have an open lattice.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_Heisenbergchain_S1_transformed(L, periodic = False):
    &#34;&#34;&#34;Loading the transformed Heisenberg chain. See https://doi.org/10.1007/BF02097239
        The transformed model is easier to solve with NetKet.

            Args:
                L (int) : The number of sites of the lattice
                periodic (bool) : True, if we have a periodic lattice. False, if we have an open lattice.
                &#34;&#34;&#34;
    print(&#39;Building the transformed S=1 Heisenberg chain&#39;)
    J = [1]
    gnx = nx.Graph()
    if (periodic == False):
        tmp = -1
    else:
        tmp = 0
    for i in range(L + tmp):
        gnx.add_edge(i, (i + 1) % L)
        print(str(i) + &#39; &#39; + str(i + 1))
    g = nk.graph.Graph(nodes=list(gnx.nodes), edges=list(gnx.edges))

    # Printing out the graph information
    #print(&#39;This graph has &#39; + str(g.n_nodes) + &#39; sites&#39;)
    #print(&#39;with the following set of edges: &#39; + str(g.n_edges))

    hi = nk.hilbert.Spin(s=1, N=g.n_nodes)

    interaction = np.asarray([[-1, 0, 0, 0, -1, 0, 0, 0, 0], [0, 0, 0, -1, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0],
                              [0, -1, 0, 0, 0, 0, 0, 0, 0], [-1, 0, 0, 0, 0, 0, 0, 0, -1], [0, 0, 0, 0, 0, 0, 0, -1, 0],
                              [0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, -1, 0, 0, 0], [0, 0, 0, 0, -1, 0, 0, 0, -1]])

    bond_operator = [
        (J[0] * interaction).tolist(),
    ]

    # Custom Graph Hamiltonian operator
    ha = nk.operator.GraphOperator(hi, g, bond_ops=bond_operator)

    return ha, hi, g</code></pre>
</details>
</dd>
<dt id="my_models.get_hamiltonian"><code class="name flex">
<span>def <span class="ident">get_hamiltonian</span></span>(<span>hamiltonian_name, L, periodic=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Method to choose the desired model.
Mutiple models can be easily chosen.</p>
<pre><code>Args:
    L (int) : The number of sites of the lattice
    periodic (bool) : True, if we have a periodic lattice. False, if we have an open lattice.
    hamiltonian_name (str) : Possible Inputs are 'transformed_Heisenberg', 'original_heisenberg',
            'transformed_AKLT', 'original_AKLT'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_hamiltonian(hamiltonian_name, L, periodic = False):
    &#34;&#34;&#34;Method to choose the desired model.
        Mutiple models can be easily chosen.

            Args:
                L (int) : The number of sites of the lattice
                periodic (bool) : True, if we have a periodic lattice. False, if we have an open lattice.
                hamiltonian_name (str) : Possible Inputs are &#39;transformed_Heisenberg&#39;, &#39;original_heisenberg&#39;,
                        &#39;transformed_AKLT&#39;, &#39;original_AKLT&#39;
                &#34;&#34;&#34;
    if(hamiltonian_name == &#39;transformed_Heisenberg&#39;):
        return build_Heisenbergchain_S1_transformed(L, periodic)
    elif(hamiltonian_name == &#39;original_Heisenberg&#39;):
        return build_Heisenbergchain_S1(L, periodic)
    elif(hamiltonian_name == &#39;transformed_AKLT&#39;):
        return build_AKLTchain_transformed(L, periodic)
    elif(hamiltonian_name == &#39;original_AKLT&#39;):
        return build_AKLTchain(L, periodic)
    else:
        print(&#39;The desired hamiltonian was spelled wrong!&#39;)
        sys.stdout.flush()
        return None</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="my_models.build_AKLTchain" href="#my_models.build_AKLTchain">build_AKLTchain</a></code></li>
<li><code><a title="my_models.build_AKLTchain_transformed" href="#my_models.build_AKLTchain_transformed">build_AKLTchain_transformed</a></code></li>
<li><code><a title="my_models.build_Heisenbergchain_S1" href="#my_models.build_Heisenbergchain_S1">build_Heisenbergchain_S1</a></code></li>
<li><code><a title="my_models.build_Heisenbergchain_S1_transformed" href="#my_models.build_Heisenbergchain_S1_transformed">build_Heisenbergchain_S1_transformed</a></code></li>
<li><code><a title="my_models.get_hamiltonian" href="#my_models.get_hamiltonian">get_hamiltonian</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>