<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>helping_functions API documentation</title>
<meta name="description" content="File with useful functions â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>helping_functions</code></h1>
</header>
<section id="section-intro">
<p>File with useful functions</p>
<p>I added some helpful functions that I use in my other files.</p>
<p>This project requires the following libraries:
netket, numpy, scipy, jax, jaxlib, networkx, torch, tqdm, matplotlib</p>
<p>This file contains the following functions:</p>
<pre><code>* Lanczos
* get_operator
* create_path
* create_machinefile
* test_operator_startingpoint
* test_operator_both_sides
* power_method
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;File with useful functions

I added some helpful functions that I use in my other files.

This project requires the following libraries:
netket, numpy, scipy, jax, jaxlib, networkx, torch, tqdm, matplotlib

This file contains the following functions:

    * Lanczos
    * get_operator
    * create_path
    * create_machinefile
    * test_operator_startingpoint
    * test_operator_both_sides
    * power_method
&#34;&#34;&#34;
import scipy
import numpy as np
import my_operators as operators
import os
import sys


def Lanczos(hamilton, L):
    &#34;&#34;&#34;Lanczos method to calculate the ground state energy of a hamiltonian.
        It only works for L&lt;= 12. If L is larger, it returns None to prevent memory overflow.

            Args:
                hamiltonian (netket.hamiltonian) : hamiltonian
                L (int) : Lattice size

            Returns:
                exact_ens (float) : exact ground state energy
                                                &#34;&#34;&#34;
    if L &lt;= 12:
        exact_ens = scipy.sparse.linalg.eigsh(hamilton.to_sparse(), k=1, which=&#39;SA&#39;, return_eigenvectors=False)
        print(&#34;Exact energy is : &#34;, exact_ens[0])
        return exact_ens
    else:
        print(&#39;Too big for exact diagonalization&#39;)
        return None


def get_operator(hilbert, L, operator = None, symmetric = True):
    &#34;&#34;&#34;Method to get the observable, that is measured.
        It works with FerroCorrelationZ and StringCorrelation. I recommend to use symmetric = False.
        symmetric=True works only for &#39;FerroCorrelationZ&#39;. I did not implement it for StringCorrelation.

            Args:
                hilbert (netket.hilbert) : hilbert space
                L (int) : Lattice size
                operator (str) : allowed inputs are &#39;FerroCorr&#39;, &#39;StringCorr&#39; and &#39;S_Z_squared&#39;
                symmetric (bool) : If True, the observable is measured symmetric to the center of the lattice.
                                    If False, the measurement is started at the 0-th site.

            Returns:
                observables (dict) : dictionary with names of observable (str) and observables (netket.operator)
                                                    &#34;&#34;&#34;
    observables = {}
    if(operator == &#39;FerroCorr&#39;):
        if(symmetric==False):
            for i in range(1, L):
                observ_fast = operators.FerroCorrelationZ(hilbert=hilbert, j=0, k=i)
                name_fast = &#39;Ferro_correlation_function&#39; + str(i)
                observables[name_fast] = observ_fast
        else:
            for i in range(1, int(L/2.) + L%2):
                observ_fast = operators.FerroCorrelationZ(hilbert=hilbert, j=int(L/2.)-i, k=int(L/2.)+i)
                name_fast = &#39;Symmetric_Ferro_correlation_function&#39; + str(int(2*i)) #because k-j=2*i
                observables[name_fast] = observ_fast
    elif(operator == &#39;StringCorr&#39;):
        for i in range(1, L):
            observ_fast = operators.StringCorrelation(hilbert=hilbert, j=0, k=i)
            name_fast = &#39;String_correlation_function&#39; + str(i)
            observables[name_fast] = observ_fast
    elif(operator == &#39;FerroCorr_slow&#39;):
        for i in range(2, np.minimum(L + 1, 9)):
            observ = operators.FerroCorrelationZ_slow(hilbert, l = i)
            name = &#39;Ferro_correlation_function_slow&#39; + str(i-1)
            observables[name] = observ
    elif(operator == &#39;S_Z_squared&#39;):
        for i in range(0, L):
            observ_fast = operators.S_Z_squared(hilbert=hilbert, j=i)
            name_fast = &#39;S_Z_squared&#39; + str(i)
            observables[name_fast] = observ_fast
    return observables


def create_path(dataname, path=&#39;run&#39;):
    &#34;&#34;&#34;Function to create new folders, if needed.
            Simply create a new path with this function. It is ensured that all folders do exist.

                Args:
                    dataname (str) : the name of the file
                    path (str) : the path to the file without the file

                Returns:
                    fullpath (str) : complete path
                                                        &#34;&#34;&#34;
    try:
        os.makedirs(path)
    except OSError:
        print(&#34;Creation of the directory %s failed&#34; % path)
    else:
        print(&#34;Successfully created the directory %s&#34; % path)
    fullpath = &#39;/&#39;.join((path, dataname))
    return fullpath


def create_machinefile(machine_name, L, alpha, dataname, use_sr):
    &#34;&#34;&#34;Function to create new folders, if needed.
                Simply create a new path with this function. It is ensured that all folders do exist.

                    Args:
                        machine_name (str) : the name of the machine
                        L (int) : the lattice size
                        alpha (int) : the hyperparameter alpha of the neural network
                        dataname (str) : name of the file
                        use_sr (float) : the diag shift. If Gd is used, use_sr = None
                                                            &#34;&#34;&#34;
    with open(&#39;&#39;.join((dataname, &#39;.machine&#39;)), &#39;w&#39;) as f:
        f.write(&#39;&#39;.join((machine_name, &#39;\n&#39;)))
        f.write(&#39;&#39;.join((&#39;L = &#39;, str(L), &#39;\n&#39;)))
        f.write(&#39;&#39;.join((&#39;Alpha = &#39;, str(alpha), &#39;\n&#39;)))
        f.write(&#39;&#39;.join((&#39;diag_shift = &#39;, str(use_sr), &#39;\n&#39;)))


def test_operator_startingpoint(hilbert, L, fast=True):
    &#34;&#34;&#34;Method to compare the effect of the starting site of the observable FerroCorrelationZ.
        I recommend to use fast=True to use the fast implementation of FerroCorrelationZ.

            Args:
                hilbert (netket.hilbert) : hilbert space
                L (int) : Lattice size
                fast (bool) : Use True

                Returns:
                    observables (dict) : dictionary with names of observable (str) and observables (netket.operator)
                                                        &#34;&#34;&#34;
    observables = {}
    if(fast == True):
        for start, j in enumerate([1, 2, 3, 4, 5, int(L/5.), int(L/4.), int(L/3.), int(L/2.), int(3 * L/2.)]):
            for k in range(j+1, L):
                observ_fast = operators.FerroCorrelationZ(hilbert=hilbert, j=j, k=k)
                name_fast = &#39;&#39;.join((str(j), &#39;Ferro_correlation_function&#39;, str(k - j)))
                observables[name_fast] = observ_fast
    else:
        for start, j in enumerate([1, 2, 3, 4, 5, int(L/5.), int(L/4.), int(L/2.), int(3 * L/2.)]):
            for k in range(j+1, np.minimum(j + 8, L)):
                observ_fast = operators.FerroCorrelationZ_slow(hilbert, j, k)
                name_fast = &#39;&#39;.join((str(j), &#39;Ferro_correlation_function&#39;, str(k - j)))
                observables[name_fast] = observ_fast
    return observables


def test_operator_both_sides(hilbert, L):
    &#34;&#34;&#34;Method to check if the result is symmetric.
        Starting point is the center of the lattice. It goes from the center to the left
        and from the center to the right.

            Args:
                hilbert (netket.hilbert) : hilbert space
                L (int) : Lattice size

            Returns:
                observables (dict) : dictionary with names of observable (str) and observables (netket.operator)
                                                            &#34;&#34;&#34;
    observables = {}
    for i in range(1, int(L/2.)):
        observ_fast = operators.FerroCorrelationZ(hilbert=hilbert, j=int(L/2.), k=int(L/2.) + i)
        name_fast = &#39;Ferro_correlation_function&#39; + str(i)
        observ_fast_mirrored = operators.FerroCorrelationZ(hilbert=hilbert, j=int(L / 2.), k=int(L / 2.) - i)
        name_fast_mirrored = &#39;Ferro_correlation_function_mirrored&#39; + str(i)
        observables[name_fast] = observ_fast
        observables[name_fast_mirrored] = observ_fast_mirrored
    return observables


def power_method(hamiltonian, L, eigenvalue_lanczos):
    &#34;&#34;&#34;Calculates the gound state vector.

        At the moment it works only if the ground state energy is the dominant eigenvalue.
        It needs a lot of RAM. Therefore, use it only for small lattices.

            Args:
                hamiltonian (scipy.sparse) : use to_dense of netket.hamiltonian object.
                L (int) : Lattice size
                eigenvalue_lanczos (float) : exact ground state energy

            Returns:
                x (numpy.array) : ground state of the hamiltonian.
                                                            &#34;&#34;&#34;

    #generate starting vector
    x = np.random.random_sample(3**L) - 0.5 #+ np.random.random_sample(3**L) * 1j - 0.5j
    x = x / np.linalg.norm(x)
    #find the eigenvector
    for i in range(1, 50000):
        x = hamiltonian.dot(x)
        eigval = np.linalg.norm(x)
        if (i % 250 == 0):
            print(&#39;guess of eigenvalue&#39;, eigval)
            sys.stdout.flush()
        x = x / np.linalg.norm(x)
        if (np.abs(np.abs(eigenvalue_lanczos) - np.abs(eigval)) &lt; 0.000001):
            print(&#39;Found solution&#39;, eigval)
            sys.stdout.flush()
            print(&#39;Needed steps:&#39;, i)
            sys.stdout.flush()
            return x
    print(&#39;Did not find a proper solution. Found&#39;, eigval)
    sys.stdout.flush()
    return x</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="helping_functions.Lanczos"><code class="name flex">
<span>def <span class="ident">Lanczos</span></span>(<span>hamilton, L)</span>
</code></dt>
<dd>
<div class="desc"><p>Lanczos method to calculate the ground state energy of a hamiltonian.
It only works for L&lt;= 12. If L is larger, it returns None to prevent memory overflow.</p>
<pre><code>Args:
    hamiltonian (netket.hamiltonian) : hamiltonian
    L (int) : Lattice size

Returns:
    exact_ens (float) : exact ground state energy
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Lanczos(hamilton, L):
    &#34;&#34;&#34;Lanczos method to calculate the ground state energy of a hamiltonian.
        It only works for L&lt;= 12. If L is larger, it returns None to prevent memory overflow.

            Args:
                hamiltonian (netket.hamiltonian) : hamiltonian
                L (int) : Lattice size

            Returns:
                exact_ens (float) : exact ground state energy
                                                &#34;&#34;&#34;
    if L &lt;= 12:
        exact_ens = scipy.sparse.linalg.eigsh(hamilton.to_sparse(), k=1, which=&#39;SA&#39;, return_eigenvectors=False)
        print(&#34;Exact energy is : &#34;, exact_ens[0])
        return exact_ens
    else:
        print(&#39;Too big for exact diagonalization&#39;)
        return None</code></pre>
</details>
</dd>
<dt id="helping_functions.create_machinefile"><code class="name flex">
<span>def <span class="ident">create_machinefile</span></span>(<span>machine_name, L, alpha, dataname, use_sr)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to create new folders, if needed.
Simply create a new path with this function. It is ensured that all folders do exist.</p>
<pre><code>Args:
    machine_name (str) : the name of the machine
    L (int) : the lattice size
    alpha (int) : the hyperparameter alpha of the neural network
    dataname (str) : name of the file
    use_sr (float) : the diag shift. If Gd is used, use_sr = None
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_machinefile(machine_name, L, alpha, dataname, use_sr):
    &#34;&#34;&#34;Function to create new folders, if needed.
                Simply create a new path with this function. It is ensured that all folders do exist.

                    Args:
                        machine_name (str) : the name of the machine
                        L (int) : the lattice size
                        alpha (int) : the hyperparameter alpha of the neural network
                        dataname (str) : name of the file
                        use_sr (float) : the diag shift. If Gd is used, use_sr = None
                                                            &#34;&#34;&#34;
    with open(&#39;&#39;.join((dataname, &#39;.machine&#39;)), &#39;w&#39;) as f:
        f.write(&#39;&#39;.join((machine_name, &#39;\n&#39;)))
        f.write(&#39;&#39;.join((&#39;L = &#39;, str(L), &#39;\n&#39;)))
        f.write(&#39;&#39;.join((&#39;Alpha = &#39;, str(alpha), &#39;\n&#39;)))
        f.write(&#39;&#39;.join((&#39;diag_shift = &#39;, str(use_sr), &#39;\n&#39;)))</code></pre>
</details>
</dd>
<dt id="helping_functions.create_path"><code class="name flex">
<span>def <span class="ident">create_path</span></span>(<span>dataname, path='run')</span>
</code></dt>
<dd>
<div class="desc"><p>Function to create new folders, if needed.
Simply create a new path with this function. It is ensured that all folders do exist.</p>
<pre><code>Args:
    dataname (str) : the name of the file
    path (str) : the path to the file without the file

Returns:
    fullpath (str) : complete path
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_path(dataname, path=&#39;run&#39;):
    &#34;&#34;&#34;Function to create new folders, if needed.
            Simply create a new path with this function. It is ensured that all folders do exist.

                Args:
                    dataname (str) : the name of the file
                    path (str) : the path to the file without the file

                Returns:
                    fullpath (str) : complete path
                                                        &#34;&#34;&#34;
    try:
        os.makedirs(path)
    except OSError:
        print(&#34;Creation of the directory %s failed&#34; % path)
    else:
        print(&#34;Successfully created the directory %s&#34; % path)
    fullpath = &#39;/&#39;.join((path, dataname))
    return fullpath</code></pre>
</details>
</dd>
<dt id="helping_functions.get_operator"><code class="name flex">
<span>def <span class="ident">get_operator</span></span>(<span>hilbert, L, operator=None, symmetric=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Method to get the observable, that is measured.
It works with FerroCorrelationZ and StringCorrelation. I recommend to use symmetric = False.
symmetric=True works only for 'FerroCorrelationZ'. I did not implement it for StringCorrelation.</p>
<pre><code>Args:
    hilbert (netket.hilbert) : hilbert space
    L (int) : Lattice size
    operator (str) : allowed inputs are 'FerroCorr', 'StringCorr' and 'S_Z_squared'
    symmetric (bool) : If True, the observable is measured symmetric to the center of the lattice.
                        If False, the measurement is started at the 0-th site.

Returns:
    observables (dict) : dictionary with names of observable (str) and observables (netket.operator)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_operator(hilbert, L, operator = None, symmetric = True):
    &#34;&#34;&#34;Method to get the observable, that is measured.
        It works with FerroCorrelationZ and StringCorrelation. I recommend to use symmetric = False.
        symmetric=True works only for &#39;FerroCorrelationZ&#39;. I did not implement it for StringCorrelation.

            Args:
                hilbert (netket.hilbert) : hilbert space
                L (int) : Lattice size
                operator (str) : allowed inputs are &#39;FerroCorr&#39;, &#39;StringCorr&#39; and &#39;S_Z_squared&#39;
                symmetric (bool) : If True, the observable is measured symmetric to the center of the lattice.
                                    If False, the measurement is started at the 0-th site.

            Returns:
                observables (dict) : dictionary with names of observable (str) and observables (netket.operator)
                                                    &#34;&#34;&#34;
    observables = {}
    if(operator == &#39;FerroCorr&#39;):
        if(symmetric==False):
            for i in range(1, L):
                observ_fast = operators.FerroCorrelationZ(hilbert=hilbert, j=0, k=i)
                name_fast = &#39;Ferro_correlation_function&#39; + str(i)
                observables[name_fast] = observ_fast
        else:
            for i in range(1, int(L/2.) + L%2):
                observ_fast = operators.FerroCorrelationZ(hilbert=hilbert, j=int(L/2.)-i, k=int(L/2.)+i)
                name_fast = &#39;Symmetric_Ferro_correlation_function&#39; + str(int(2*i)) #because k-j=2*i
                observables[name_fast] = observ_fast
    elif(operator == &#39;StringCorr&#39;):
        for i in range(1, L):
            observ_fast = operators.StringCorrelation(hilbert=hilbert, j=0, k=i)
            name_fast = &#39;String_correlation_function&#39; + str(i)
            observables[name_fast] = observ_fast
    elif(operator == &#39;FerroCorr_slow&#39;):
        for i in range(2, np.minimum(L + 1, 9)):
            observ = operators.FerroCorrelationZ_slow(hilbert, l = i)
            name = &#39;Ferro_correlation_function_slow&#39; + str(i-1)
            observables[name] = observ
    elif(operator == &#39;S_Z_squared&#39;):
        for i in range(0, L):
            observ_fast = operators.S_Z_squared(hilbert=hilbert, j=i)
            name_fast = &#39;S_Z_squared&#39; + str(i)
            observables[name_fast] = observ_fast
    return observables</code></pre>
</details>
</dd>
<dt id="helping_functions.power_method"><code class="name flex">
<span>def <span class="ident">power_method</span></span>(<span>hamiltonian, L, eigenvalue_lanczos)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the gound state vector.</p>
<p>At the moment it works only if the ground state energy is the dominant eigenvalue.
It needs a lot of RAM. Therefore, use it only for small lattices.</p>
<pre><code>Args:
    hamiltonian (scipy.sparse) : use to_dense of netket.hamiltonian object.
    L (int) : Lattice size
    eigenvalue_lanczos (float) : exact ground state energy

Returns:
    x (numpy.array) : ground state of the hamiltonian.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def power_method(hamiltonian, L, eigenvalue_lanczos):
    &#34;&#34;&#34;Calculates the gound state vector.

        At the moment it works only if the ground state energy is the dominant eigenvalue.
        It needs a lot of RAM. Therefore, use it only for small lattices.

            Args:
                hamiltonian (scipy.sparse) : use to_dense of netket.hamiltonian object.
                L (int) : Lattice size
                eigenvalue_lanczos (float) : exact ground state energy

            Returns:
                x (numpy.array) : ground state of the hamiltonian.
                                                            &#34;&#34;&#34;

    #generate starting vector
    x = np.random.random_sample(3**L) - 0.5 #+ np.random.random_sample(3**L) * 1j - 0.5j
    x = x / np.linalg.norm(x)
    #find the eigenvector
    for i in range(1, 50000):
        x = hamiltonian.dot(x)
        eigval = np.linalg.norm(x)
        if (i % 250 == 0):
            print(&#39;guess of eigenvalue&#39;, eigval)
            sys.stdout.flush()
        x = x / np.linalg.norm(x)
        if (np.abs(np.abs(eigenvalue_lanczos) - np.abs(eigval)) &lt; 0.000001):
            print(&#39;Found solution&#39;, eigval)
            sys.stdout.flush()
            print(&#39;Needed steps:&#39;, i)
            sys.stdout.flush()
            return x
    print(&#39;Did not find a proper solution. Found&#39;, eigval)
    sys.stdout.flush()
    return x</code></pre>
</details>
</dd>
<dt id="helping_functions.test_operator_both_sides"><code class="name flex">
<span>def <span class="ident">test_operator_both_sides</span></span>(<span>hilbert, L)</span>
</code></dt>
<dd>
<div class="desc"><p>Method to check if the result is symmetric.
Starting point is the center of the lattice. It goes from the center to the left
and from the center to the right.</p>
<pre><code>Args:
    hilbert (netket.hilbert) : hilbert space
    L (int) : Lattice size

Returns:
    observables (dict) : dictionary with names of observable (str) and observables (netket.operator)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_operator_both_sides(hilbert, L):
    &#34;&#34;&#34;Method to check if the result is symmetric.
        Starting point is the center of the lattice. It goes from the center to the left
        and from the center to the right.

            Args:
                hilbert (netket.hilbert) : hilbert space
                L (int) : Lattice size

            Returns:
                observables (dict) : dictionary with names of observable (str) and observables (netket.operator)
                                                            &#34;&#34;&#34;
    observables = {}
    for i in range(1, int(L/2.)):
        observ_fast = operators.FerroCorrelationZ(hilbert=hilbert, j=int(L/2.), k=int(L/2.) + i)
        name_fast = &#39;Ferro_correlation_function&#39; + str(i)
        observ_fast_mirrored = operators.FerroCorrelationZ(hilbert=hilbert, j=int(L / 2.), k=int(L / 2.) - i)
        name_fast_mirrored = &#39;Ferro_correlation_function_mirrored&#39; + str(i)
        observables[name_fast] = observ_fast
        observables[name_fast_mirrored] = observ_fast_mirrored
    return observables</code></pre>
</details>
</dd>
<dt id="helping_functions.test_operator_startingpoint"><code class="name flex">
<span>def <span class="ident">test_operator_startingpoint</span></span>(<span>hilbert, L, fast=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Method to compare the effect of the starting site of the observable FerroCorrelationZ.
I recommend to use fast=True to use the fast implementation of FerroCorrelationZ.</p>
<pre><code>Args:
    hilbert (netket.hilbert) : hilbert space
    L (int) : Lattice size
    fast (bool) : Use True

    Returns:
        observables (dict) : dictionary with names of observable (str) and observables (netket.operator)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_operator_startingpoint(hilbert, L, fast=True):
    &#34;&#34;&#34;Method to compare the effect of the starting site of the observable FerroCorrelationZ.
        I recommend to use fast=True to use the fast implementation of FerroCorrelationZ.

            Args:
                hilbert (netket.hilbert) : hilbert space
                L (int) : Lattice size
                fast (bool) : Use True

                Returns:
                    observables (dict) : dictionary with names of observable (str) and observables (netket.operator)
                                                        &#34;&#34;&#34;
    observables = {}
    if(fast == True):
        for start, j in enumerate([1, 2, 3, 4, 5, int(L/5.), int(L/4.), int(L/3.), int(L/2.), int(3 * L/2.)]):
            for k in range(j+1, L):
                observ_fast = operators.FerroCorrelationZ(hilbert=hilbert, j=j, k=k)
                name_fast = &#39;&#39;.join((str(j), &#39;Ferro_correlation_function&#39;, str(k - j)))
                observables[name_fast] = observ_fast
    else:
        for start, j in enumerate([1, 2, 3, 4, 5, int(L/5.), int(L/4.), int(L/2.), int(3 * L/2.)]):
            for k in range(j+1, np.minimum(j + 8, L)):
                observ_fast = operators.FerroCorrelationZ_slow(hilbert, j, k)
                name_fast = &#39;&#39;.join((str(j), &#39;Ferro_correlation_function&#39;, str(k - j)))
                observables[name_fast] = observ_fast
    return observables</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="helping_functions.Lanczos" href="#helping_functions.Lanczos">Lanczos</a></code></li>
<li><code><a title="helping_functions.create_machinefile" href="#helping_functions.create_machinefile">create_machinefile</a></code></li>
<li><code><a title="helping_functions.create_path" href="#helping_functions.create_path">create_path</a></code></li>
<li><code><a title="helping_functions.get_operator" href="#helping_functions.get_operator">get_operator</a></code></li>
<li><code><a title="helping_functions.power_method" href="#helping_functions.power_method">power_method</a></code></li>
<li><code><a title="helping_functions.test_operator_both_sides" href="#helping_functions.test_operator_both_sides">test_operator_both_sides</a></code></li>
<li><code><a title="helping_functions.test_operator_startingpoint" href="#helping_functions.test_operator_startingpoint">test_operator_startingpoint</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>